Structure BooleanAlgebra := {
 carrier :> Set; (* Coercion *)
 and : carrier -> carrier-> carrier;
 or : carrier -> carrier -> carrier;
 neg : carrier -> carrier;
 zero : carrier;
 one : carrier;
 and_p_0 : forall p, and p zero = zero;
 and_p_1 : forall p, and p one = p;
 and_p_Np : forall p, and p (neg p) = zero;
 and_p_p : forall p, and p p = p;
 neg_0 : neg zero = one;
 neg_neg : forall p, neg (neg p) = p;
 or_p_1 : forall p, or p one = one;
 or_p_0 : forall p, or p zero = p;
 or_p_Np : forall p, or p (neg p) = one;
 or_p_p : forall p, or p p = p;
 neg_or : forall p q, neg (or p q) = and (neg p) (neg q);
 neg_and : forall p q, neg (and p q) = or (neg p) (neg q);
 and_or : forall p q r, and p (or q r) = or (and p q) (and p r);
 or_and : forall p q r, or p (and q r) = and (or p q) (or p r);
 and_p_qr : forall p q r, and p (and q r) = and (and p q) r;
 or_p_qr : forall p q r, or p (or q r) = or (or p q) r;
 and_pq : forall p q, and p q = and q p;
 or_pq : forall p q, or p q = or q p
}.

Notation "p & q" := (and _ p q) (at level 40, left associativity).
Notation "p | q" := (or _ p q) (at level 50, left associativity).
Notation "! p" := (neg _ p) (at level 20).
Notation "1" := (one _).
Notation "0" := (zero _).

Lemma and_pq_r (B : BooleanAlgebra) (p q r : B) :
  (p | q) & r = p & r | q & r.
Proof.
 rewrite <-and_pq.
 rewrite->and_or.
 rewrite->and_pq.
 rewrite->or_pq.
 rewrite->and_pq.
 rewrite->or_pq.
 reflexivity.
Qed.




Lemma neg_1 (L : BooleanAlgebra) : ! 1 = (0 : L).
Proof.
  rewrite <- neg_0.
  rewrite -> neg_neg.
  reflexivity.
Qed.

Definition Two : BooleanAlgebra.
Proof.
  (* We use bool and its operations from the standard library *)
  refine {| carrier := bool ;
            and := andb ;
            or := orb ;
            neg := negb ;
            zero := false ;
            one := true
         |} ; repeat (intros [|]) ; reflexivity.
Defined.

Definition pointwise0 {B : Set} (c : B) (I : Set) :
  (I -> B) :=
  fun i => c.

Definition pointwise1 {B : Set} (op : B -> B) (I : Set) :
  (I -> B) -> (I -> B) :=
  fun f i => op (f i).

Definition pointwise2 {B : Set} (op : B -> B -> B) (I : Set) :
  (I -> B) -> (I -> B) -> (I -> B) :=
  fun f g i => op (f i) (g i).

(* Function extensionality. *)
Axiom funext :
  forall (X : Type) (P : X -> Type) (f g : (forall x, P x)),
    (forall x, f x = g x) -> f = g.

(* Function extensionality for simple types. *)
Lemma funext_simple (X Y : Type) (f g : X -> Y) :
  (forall x, f x = g x) -> f = g.
Proof.
  apply (funext X (fun x => Y)).
Defined.

Definition Power (B : BooleanAlgebra) (I : Set) : BooleanAlgebra.
Proof.
  refine {| carrier := I -> B ;
            and := pointwise2 (and B) I ;
            or := pointwise2 (or B) I ;
            neg := pointwise1 (neg B) I ;
            zero := pointwise0 (zero B) I ;
            one := pointwise0 (one B) I
         |} ;
  (intros ; apply funext_simple ; intro i ; unfold pointwise0, pointwise1, pointwise2).
  - apply and_p_0.
  - apply and_p_1.
  - apply and_p_Np.
  - apply and_p_p.
  - apply neg_0.
  - apply neg_neg.
  - apply or_p_1.
  - apply or_p_0.
  - apply or_p_Np.
  - apply or_p_p.
  - apply neg_or.
  - apply neg_and.
  - apply and_or.
  - apply or_and.
  - apply and_p_qr.
  - apply or_p_qr.
  - apply and_pq.
  - apply or_pq.
Defined.

Inductive Colors := Red | Green | Blue.

(* Boolean algebra with eight elements. *)
Definition EightBA := Power Two Colors.

(* The opposite algebra. *)
Definition Opposite (B : BooleanAlgebra) : BooleanAlgebra.
Proof.
  refine {| carrier := carrier B ;
            and := or B ;
            or := and B ;
            neg := neg B ;
            one := zero B ;
            zero := one B
         |}.
intros.
-apply or_p_1.
-apply or_p_0.
-apply or_p_Np.
-apply or_p_p.
-apply neg_1.
-apply neg_neg.
-apply and_p_0.
-apply and_p_1.
-apply and_p_Np.
-apply and_p_p.
-apply neg_and.
-apply neg_or.
-apply or_and.
-apply and_or.
-apply or_p_qr.
-apply and_p_qr.
-apply or_pq.
-apply and_pq.
Defined.

(*Defining the Boolean algebra morphism*)



Structure Poset := {
  poset_carrier :> Type;
  leq : poset_carrier -> poset_carrier -> Prop ;
  leq_refl : forall x, leq x x ;
  leq_tran : forall x y z, leq x y -> leq y z -> leq x z;
  leq_antisym : forall x y, leq x y -> leq y x -> x = y
}.

Notation "x <= y" := (leq _ x y) (at level 70, no associativity).

Definition discrete (A : Type) : Poset.
Proof.
  refine {| poset_carrier := A ; leq := (fun x y => x = y) |}.
  - auto.
  - intros. transitivity y ; auto.
  - intros. assumption.
Defined.

(* Every Boolean algebra is a poset. *)
Definition BAPoset (B : BooleanAlgebra) : Poset.
Proof.
  refine {| poset_carrier := carrier B ;
            leq := fun x y => (x & y = x)
         |}.
  - apply and_p_p.
   -intros.
 rewrite <- H.
rewrite H.







